"use strict";(self.webpackChunkmy_docs_website=self.webpackChunkmy_docs_website||[]).push([[3541],{12693:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>i,contentTitle:()=>n,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var r=t(74848),s=t(28453);const l={slug:"parallel-execution-V",title:"Mastering Parallel Execution in OceanBase Database: Part 5 - Parallel Execution Parameters"},n=void 0,o={id:"blogs/tech/parallel-execution-V",title:"Mastering Parallel Execution in OceanBase Database: Part 5 - Parallel Execution Parameters",description:"OceanBase Database provides a group of parameters for you to control the initialization and tuning of parallel execution. When OceanBase Database starts, the default values of parallel execution parameters can be calculated based on the number of CPU cores of the tenant and the tenant-level parameter pxworkerspercpuquota. You can also choose not to use the default values but to manually specify parameter values upon startup of OceanBase Database or manually adjust the parameter values later as needed. By default, parallel execution is enabled.",source:"@site/docs/blogs/tech/parallel-execution-V.md",sourceDirName:"blogs/tech",slug:"/blogs/tech/parallel-execution-V",permalink:"/docs/blogs/tech/parallel-execution-V",draft:!1,unlisted:!1,editUrl:"https://github.com/oceanbase/oceanbase.github.io/tree/main/docs/blogs/tech/parallel-execution-V.md",tags:[],version:"current",frontMatter:{slug:"parallel-execution-V",title:"Mastering Parallel Execution in OceanBase Database: Part 5 - Parallel Execution Parameters"},sidebar:"blogsSidebar",previous:{title:"Mastering Parallel Execution in OceanBase Database: Part 4 - Parallel Execution Types",permalink:"/docs/blogs/tech/parallel-execution-IV"},next:{title:"Mastering Parallel Execution in OceanBase Database: Part 6 - Troubleshooting and Tuning Tips",permalink:"/docs/blogs/tech/parallel-execution-VI"}},i={},c=[{value:"5.1 Default Values of Parallel Execution Parameters",id:"51-default-values-of-parallel-execution-parameters",level:2},{value:"px_workers_per_cpu_quota",id:"px_workers_per_cpu_quota",level:3},{value:"parallel_servers_target",id:"parallel_servers_target",level:3},{value:"parallel_degree_policy",id:"parallel_degree_policy",level:3},{value:"5.2 Tuning of Parallel Execution Parameters",id:"52-tuning-of-parallel-execution-parameters",level:2},{value:"ob_sql_work_area_percentage",id:"ob_sql_work_area_percentage",level:3},{value:"workarea_size_policy",id:"workarea_size_policy",level:3},{value:"_hash_area_size",id:"_hash_area_size",level:3},{value:"_sort_area_size",id:"_sort_area_size",level:3},{value:"_px_shared_hash_join",id:"_px_shared_hash_join",level:3},{value:"5.3 Tuning of Parallel DML Parameters",id:"53-tuning-of-parallel-dml-parameters",level:2}];function h(e){const a={a:"a",blockquote:"blockquote",br:"br",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(a.blockquote,{children:["\n",(0,r.jsxs)(a.p,{children:["OceanBase Database provides a group of parameters for you to control the initialization and tuning of parallel execution. When OceanBase Database starts, the default values of parallel execution parameters can be calculated based on the number of CPU cores of the tenant and the tenant-level parameter ",(0,r.jsx)(a.code,{children:"px_workers_per_cpu_quota"}),". You can also choose not to use the default values but to manually specify parameter values upon startup of OceanBase Database or manually adjust the parameter values later as needed. By default, parallel execution is enabled.",(0,r.jsx)(a.br,{}),"\n","This article introduces techniques for controlling parallel execution parameters from two aspects: default values and tuning of parallel execution parameters."]}),"\n"]}),"\n",(0,r.jsx)(a.p,{children:"This is the fifth article of a seven-part series on parallel execution."}),"\n",(0,r.jsx)(a.p,{children:"Part 1"}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-I",children:"Introduction"})}),"\n",(0,r.jsx)(a.p,{children:"Part 2"}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-II",children:"Set the DOP"})}),"\n",(0,r.jsx)(a.p,{children:"Part 3"}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-III",children:"Concurrency Control and Queuing"})}),"\n",(0,r.jsx)(a.p,{children:"Part 4"}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-IV",children:"Parallel Execution Types"})}),"\n",(0,r.jsx)(a.p,{children:"Part 5"}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-V",children:"Parallel Execution Parameters"})}),"\n",(0,r.jsx)(a.p,{children:"Part 6"}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-VI",children:"Troubleshooting and Tuning Tips"})}),"\n",(0,r.jsx)(a.p,{children:"Part 7"}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-VII",children:"Get Started with a PoC Test"})}),"\n",(0,r.jsx)(a.h2,{id:"51-default-values-of-parallel-execution-parameters",children:"5.1 Default Values of Parallel Execution Parameters"}),"\n",(0,r.jsx)(a.p,{children:"You can set parallel execution parameters to control the number of parallel execution (PX) threads and queuing in parallel execution. The following table describes the parameters."}),"\n",(0,r.jsxs)(a.table,{children:[(0,r.jsx)(a.thead,{children:(0,r.jsxs)(a.tr,{children:[(0,r.jsx)(a.th,{children:"Parameter name"}),(0,r.jsx)(a.th,{children:"Default value"}),(0,r.jsx)(a.th,{children:"Level"}),(0,r.jsx)(a.th,{children:"Description"})]})}),(0,r.jsxs)(a.tbody,{children:[(0,r.jsxs)(a.tr,{children:[(0,r.jsx)(a.td,{children:"px_workers_per_cpu_quota"}),(0,r.jsx)(a.td,{children:"10"}),(0,r.jsx)(a.td,{children:"Tenant-level parameter"}),(0,r.jsx)(a.td,{children:"The number of PX threads that can be allocated on each CPU core. Value range: [1, 20]."})]}),(0,r.jsxs)(a.tr,{children:[(0,r.jsx)(a.td,{children:"parallel_servers_target"}),(0,r.jsx)(a.td,{children:"MIN CPU \xd7 px_workers_per_cpu_quota"}),(0,r.jsx)(a.td,{children:"Tenant-level variable"}),(0,r.jsx)(a.td,{children:"The number of PX threads that can be requested from each node of the tenant."})]}),(0,r.jsxs)(a.tr,{children:[(0,r.jsx)(a.td,{children:"parallel_degree_policy"}),(0,r.jsx)(a.td,{children:"MANUAL"}),(0,r.jsx)(a.td,{children:"Tenant-level or session-level variable"}),(0,r.jsxs)(a.td,{children:["The auto degree of parallelism (DOP) strategy. You can set the value to ",(0,r.jsx)(a.code,{children:"AUTO"})," to enable auto DOP. After auto DOP is enabled, the optimizer automatically calculates the DOP for queries based on statistics. If you set the value to ",(0,r.jsx)(a.code,{children:"MANUAL"}),", you can specify a DOP by using hints, a table-level PARALLEL attribute, or a session-level PARALLEL attribute."]})]}),(0,r.jsxs)(a.tr,{children:[(0,r.jsx)(a.td,{children:"_parallel_max_active_sessions"}),(0,r.jsx)(a.td,{children:"0"}),(0,r.jsx)(a.td,{children:"Tenant-level parameter"}),(0,r.jsxs)(a.td,{children:["In the TPC-H benchmark, a power run requires a higher DOP than a throughput run. However, the TPC-H specification disallows dynamic changes to the DOP by using SQL. To support dynamic changes to the DOP, the ",(0,r.jsx)(a.code,{children:"_parallel_max_active_sessions"})," parameter is introduced. When the value of ",(0,r.jsx)(a.code,{children:"_parallel_max_active_sessions"})," is ",(0,r.jsx)(a.code,{children:"0"}),", the number of active sessions that can be executed in parallel is unlimited. When the value of ",(0,r.jsx)(a.code,{children:"_parallel_max_active_sessions"})," is greater than ",(0,r.jsx)(a.code,{children:"0"}),", the value indicates the number of active sessions that can be executed in parallel. The threads of the extra sessions are suspended. After a query is completed, the suspended session threads are woken up to resume."]})]})]})]}),"\n",(0,r.jsx)(a.p,{children:"To lower the requirements for using parallel execution, OceanBase Database minimizes the number of parallel execution parameters. You can use the default values to directly enable parallel execution. In special scenarios, you can change the parameter values for optimization."}),"\n",(0,r.jsx)(a.h3,{id:"px_workers_per_cpu_quota",children:"px_workers_per_cpu_quota"}),"\n",(0,r.jsxs)(a.p,{children:["This parameter specifies the number of PX threads that can be allocated on each CPU core. Assume that the value of ",(0,r.jsx)(a.code,{children:"MIN_CPU"})," of the tenant is N. If the data to be processed in parallel is evenly distributed, the number of threads that can be allocated on each node is calculated by using the following formula: N \xd7 Value of ",(0,r.jsx)(a.code,{children:"px_workers_per_cpu_quota"}),". If the data is unevenly distributed, the actual number of threads allocated on some nodes may exceed the value calculated by using the foregoing formula for a short time. After the parallel execution is completed, the excess threads are automatically reclaimed."]}),"\n",(0,r.jsxs)(a.p,{children:[(0,r.jsx)(a.code,{children:"px_workers_per_cpu_quota"})," affects the default value of ",(0,r.jsx)(a.code,{children:"parallel_servers_target"})," only during tenant creation. If you change the value of ",(0,r.jsx)(a.code,{children:"px_workers_per_cpu_quota"})," after the tenant is created, the value of ",(0,r.jsx)(a.code,{children:"parallel_servers_target"})," is not affected."]}),"\n",(0,r.jsxs)(a.p,{children:["Generally, you do not need to change the default value of ",(0,r.jsx)(a.code,{children:"px_workers_per_cpu_quota"}),". If all CPU resources are occupied by parallel execution when resource isolation is disabled, you can try to decrease the value of ",(0,r.jsx)(a.code,{children:"px_workers_per_cpu_quota"})," to lower the CPU utilization."]}),"\n",(0,r.jsx)(a.h3,{id:"parallel_servers_target",children:"parallel_servers_target"}),"\n",(0,r.jsxs)(a.p,{children:["This parameter specifies the number of PX threads that can be requested from each node of the tenant. When thread resources are used up, subsequent PX requests need to wait in a queue. For the concept of queuing, see ",(0,r.jsx)(a.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-III",children:"Mastering Parallel Execution in OceanBase Database: Part 3 - Concurrency Control and Queuing"}),"."]}),"\n",(0,r.jsxs)(a.p,{children:["In parallel execution, the CPU utilization can be very low due to factors such as an excessively small value of ",(0,r.jsx)(a.code,{children:"parallel_servers_target"}),", which downgrades the DOP for the SQL statement, resulting in fewer threads allocated than expected. In OceanBase Database of a version earlier than V3.2.3, the default value of ",(0,r.jsx)(a.code,{children:"parallel_servers_target"})," is very small. You can increase the value of ",(0,r.jsx)(a.code,{children:"parallel_servers_target"})," to resolve the issue. We recommend that you set ",(0,r.jsx)(a.code,{children:"parallel_servers_target"})," to the value of ",(0,r.jsx)(a.code,{children:"MIN_CPU"})," \xd7 10. In OceanBase Database V3.2.3 and later, the default value of ",(0,r.jsx)(a.code,{children:"parallel_servers_target"})," is the value of ",(0,r.jsx)(a.code,{children:"MIN_CPU"})," \xd7 10. Therefore, this issue does not occur."]}),"\n",(0,r.jsxs)(a.p,{children:[(0,r.jsx)(a.code,{children:"MIN_CPU"})," specifies the minimum number of CPU cores for the tenant and is specified during tenant creation."]}),"\n",(0,r.jsxs)(a.p,{children:["After you set an appropriate value for ",(0,r.jsx)(a.code,{children:"parallel_servers_target"}),", reconnect to your database and execute the following statement to view the latest value:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-sql",children:"    show variables like 'parallel_servers_target';\n"})}),"\n",(0,r.jsxs)(a.p,{children:["For ease of O&M, you can set ",(0,r.jsx)(a.code,{children:"parallel_servers_target"})," to the maximum value to avoid frequent adjustment. Theoretically, you can set ",(0,r.jsx)(a.code,{children:"parallel_servers_target"})," to an infinite value. However, this results in low efficiency, because all queries are executed once they are initiated, without the need to wait in a queue, and contend for CPU time slices, disk I/Os, and network I/Os."]}),"\n",(0,r.jsxs)(a.p,{children:["This issue is not severe in terms of throughput. However, resource contention will significantly increase the latency of individual SQL statements. Considering the CPU and I/O utilization, you can set ",(0,r.jsx)(a.code,{children:"parallel_servers_target"})," to the value of ",(0,r.jsx)(a.code,{children:"MIN_CPU"})," \xd7 10. In a few I/O-intensive scenarios, CPU resources may not be fully used. In this case, you can set ",(0,r.jsx)(a.code,{children:"parallel_servers_target"})," to the value of ",(0,r.jsx)(a.code,{children:"MIN_CPU"})," \xd7 20."]}),"\n",(0,r.jsx)(a.h3,{id:"parallel_degree_policy",children:"parallel_degree_policy"}),"\n",(0,r.jsxs)(a.p,{children:["This parameter specifies the DOP strategy. Valid values are ",(0,r.jsx)(a.code,{children:"AUTO"})," and ",(0,r.jsx)(a.code,{children:"MANUAL"}),". You can set the value to ",(0,r.jsx)(a.code,{children:"AUTO"})," to enable auto DOP. In this case, the optimizer automatically calculates the DOP for queries based on statistics. If you set the value to ",(0,r.jsx)(a.code,{children:"MANUAL"}),", you can specify a DOP by using hints, a table-level PARALLEL attribute, or a session-level PARALLEL attribute."]}),"\n",(0,r.jsxs)(a.p,{children:["In OceanBase Database V4.2 and later, if you are not familiar with the DOP setting rules, you can set ",(0,r.jsx)(a.code,{children:"parallel_degree_policy"})," to ",(0,r.jsx)(a.code,{children:"AUTO"})," to allow the optimizer to automatically select a DOP. For more information about the rules for automatically calculating a DOP, see ",(0,r.jsx)(a.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-II",children:"Mastering Parallel Execution in OceanBase Database: Part 2 - Set the DOP"}),". OceanBase Database of a version earlier than V4.2 does not support the ",(0,r.jsx)(a.code,{children:"parallel_degree_policy"})," parameter, and therefore does not support the auto DOP feature. In this case, you must manually specify a DOP."]}),"\n",(0,r.jsx)(a.h2,{id:"52-tuning-of-parallel-execution-parameters",children:"5.2 Tuning of Parallel Execution Parameters"}),"\n",(0,r.jsx)(a.h3,{id:"ob_sql_work_area_percentage",children:"ob_sql_work_area_percentage"}),"\n",(0,r.jsxs)(a.p,{children:["This is a tenant-level variable that specifies the maximum memory space available for the SQL workarea. The value is in percentage that indicates the percentage of the memory space available for the SQL module to the total memory space of the tenant. The default value is ",(0,r.jsx)(a.code,{children:"5"}),", which indicates 5%. When the memory space occupied by the SQL module exceeds the specified value, data in the memory is flushed to the disk. To view the actual memory usage of the SQL workarea, you can search for ",(0,r.jsx)(a.code,{children:"WORK_AREA"})," in the ",(0,r.jsx)(a.code,{children:"observer.log"})," file. Here is an example:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-bash",children:"    [MEMORY] tenant_id=1001 ctx_id=WORK_AREA hold=2,097,152 used=0 limit=157,286,400\n"})}),"\n",(0,r.jsxs)(a.p,{children:["In a scenario with more reads than writes, if data in the memory is flushed to the disk due to insufficient memory for the SQL workarea, you can increase the value of ",(0,r.jsx)(a.code,{children:"ob_sql_work_area_percentage"}),"."]}),"\n",(0,r.jsx)(a.h3,{id:"workarea_size_policy",children:"workarea_size_policy"}),"\n",(0,r.jsxs)(a.p,{children:["OceanBase Database implements global adaptive memory management. When ",(0,r.jsx)(a.code,{children:"workarea_size_policy"})," is set to ",(0,r.jsx)(a.code,{children:"AUTO"}),", the execution framework allocates memory to operators, such as Hash Join, Group By, and Sort, based on the optimal strategy, and enables the adaptive data flush strategy. If ",(0,r.jsx)(a.code,{children:"workarea_size_policy"})," is set to ",(0,r.jsx)(a.code,{children:"MANUAL"}),", you must manually specify ",(0,r.jsx)(a.code,{children:"_hash_area_size"})," and ",(0,r.jsx)(a.code,{children:"_sort_area_size"}),"."]}),"\n",(0,r.jsx)(a.h3,{id:"_hash_area_size",children:"_hash_area_size"}),"\n",(0,r.jsxs)(a.p,{children:["This is a tenant-level parameter that allows you to manually specify the maximum memory space available for the hash algorithm of each operator. The default value is 128 MB. When the used memory space exceeds the specified value, data in the memory is flushed to the disk. This parameter applies to operators related to the hash algorithm, such as Hash Join, Hash Group By, and Hash Distinct. ",(0,r.jsxs)(a.strong,{children:["Generally, you do not need to modify the value of this parameter and we recommend that you set ",(0,r.jsx)(a.code,{children:"workarea_size_policy"})," to ",(0,r.jsx)(a.code,{children:"AUTO"}),"."]})," If you do not want the system to automatically flush data from the memory to the disk during the use of the hash algorithm, set ",(0,r.jsx)(a.code,{children:"workarea_size_policy"})," to ",(0,r.jsx)(a.code,{children:"MANUAL"})," and manually specify a ",(0,r.jsx)(a.code,{children:"_hash_area_size"})," value."]}),"\n",(0,r.jsx)(a.h3,{id:"_sort_area_size",children:"_sort_area_size"}),"\n",(0,r.jsxs)(a.p,{children:["This is a tenant-level parameter that allows you to manually specify the maximum memory space available for the sort algorithm of each operator. The default value is 128 MB. When the used memory space exceeds the specified value, data in the memory is flushed to the disk. This parameter is mainly used for the sort operator. ",(0,r.jsxs)(a.strong,{children:["Generally, you do not need to modify the value of this parameter, and we recommend that you set ",(0,r.jsx)(a.code,{children:"workarea_size_policy"})," to ",(0,r.jsx)(a.code,{children:"AUTO"}),"."]})," If you do not want the system to automatically flush data from the memory to the disk during the use of the sort algorithm, set ",(0,r.jsx)(a.code,{children:"workarea_size_policy"})," to ",(0,r.jsx)(a.code,{children:"MANUAL"})," and manually specify a ",(0,r.jsx)(a.code,{children:"_sort_area_size"})," value."]}),"\n",(0,r.jsx)(a.h3,{id:"_px_shared_hash_join",children:"_px_shared_hash_join"}),"\n",(0,r.jsxs)(a.p,{children:["This is a session-level system variable that determines whether to use a shared hash table during hash joins for optimization. The default value is ",(0,r.jsx)(a.code,{children:"true"}),", which specifies to enable the shared hash join algorithm. When a hash join is executed in parallel, each PX thread independently calculates a hash table. When the left table uses broadcast redistribution, all hash tables calculated by the PX threads are identical. Therefore, each machine needs only one hash table for all PX threads to share to improve CPU cache efficiency. ",(0,r.jsx)(a.strong,{children:"Generally, you do not need to modify the value of this parameter."})]}),"\n",(0,r.jsx)(a.h2,{id:"53-tuning-of-parallel-dml-parameters",children:"5.3 Tuning of Parallel DML Parameters"}),"\n",(0,r.jsxs)(a.p,{children:["The transaction mechanism is no longer a must in OceanBase Database V4.1 and later. Therefore, when you import data into a table, we recommend that you use the ",(0,r.jsx)(a.code,{children:"INSERT INTO SELECT"})," statement in combination with the direct load feature to insert the data into the table at a time. This can shorten the import time and avoid memory shortage caused by a high write speed."]})]})}function d(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,a,t)=>{t.d(a,{R:()=>n,x:()=>o});var r=t(96540);const s={},l=r.createContext(s);function n(e){const a=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:n(e.components),r.createElement(l.Provider,{value:a},e.children)}}}]);