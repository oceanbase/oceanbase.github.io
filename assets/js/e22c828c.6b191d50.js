"use strict";(self.webpackChunkmy_docs_website=self.webpackChunkmy_docs_website||[]).push([[654],{41826:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>i,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=t(74848),n=t(28453);const o={slug:"parallel-execution-III",title:"Mastering Parallel Execution in OceanBase Database: Part 3 - Concurrency Control and Queuing"},l=void 0,s={id:"blogs/tech/parallel-execution-III",title:"Mastering Parallel Execution in OceanBase Database: Part 3 - Concurrency Control and Queuing",description:"Parallel queries may queue while waiting for threads. This article introduces thread management in parallel execution.",source:"@site/docs/blogs/tech/parallel-execution-III.md",sourceDirName:"blogs/tech",slug:"/blogs/tech/parallel-execution-III",permalink:"/docs/blogs/tech/parallel-execution-III",draft:!1,unlisted:!1,editUrl:"https://github.com/oceanbase/oceanbase.github.io/tree/main/docs/blogs/tech/parallel-execution-III.md",tags:[],version:"current",frontMatter:{slug:"parallel-execution-III",title:"Mastering Parallel Execution in OceanBase Database: Part 3 - Concurrency Control and Queuing"},sidebar:"blogsSidebar",previous:{title:"Mastering Parallel Execution in OceanBase Database: Part 2 - Set the DOP",permalink:"/docs/blogs/tech/parallel-execution-II"},next:{title:"Mastering Parallel Execution in OceanBase Database: Part 4 - Parallel Execution Types",permalink:"/docs/blogs/tech/parallel-execution-IV"}},i={},c=[{value:"3.1 Concurrency Control in Parallel Execution",id:"31-concurrency-control-in-parallel-execution",level:2},{value:"3.2 Allocation of PX Worker Threads",id:"32-allocation-of-px-worker-threads",level:2},{value:"3.3 Two-level Resource Control Model",id:"33-two-level-resource-control-model",level:2},{value:"3.4 View Related to PX Resource Manager",id:"34-view-related-to-px-resource-manager",level:2}];function h(e){const r={a:"a",blockquote:"blockquote",code:"code",h2:"h2",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(r.blockquote,{children:["\n",(0,a.jsx)(r.p,{children:"Parallel queries may queue while waiting for threads. This article introduces thread management in parallel execution."}),"\n"]}),"\n",(0,a.jsx)(r.p,{children:"This is the third article of a seven-part series on parallel execution."}),"\n",(0,a.jsx)(r.p,{children:"Part 1"}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-I",children:"Introduction"})}),"\n",(0,a.jsx)(r.p,{children:"Part 2"}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-II",children:"Set the DOP"})}),"\n",(0,a.jsx)(r.p,{children:"Part 3"}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-III",children:"Concurrency Control and Queuing"})}),"\n",(0,a.jsx)(r.p,{children:"Part 4"}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-IV",children:"Parallel Execution Types"})}),"\n",(0,a.jsx)(r.p,{children:"Part 5"}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-V",children:"Parallel Execution Parameters"})}),"\n",(0,a.jsx)(r.p,{children:"Part 6"}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-VI",children:"Troubleshooting and Tuning Tips"})}),"\n",(0,a.jsx)(r.p,{children:"Part 7"}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.a,{href:"https://oceanbase.github.io/docs/blogs/tech/parallel-execution-VII",children:"Get Started with a PoC Test"})}),"\n",(0,a.jsx)(r.h2,{id:"31-concurrency-control-in-parallel-execution",children:"3.1 Concurrency Control in Parallel Execution"}),"\n",(0,a.jsxs)(r.p,{children:["You can use the tenant-level variable ",(0,a.jsx)(r.code,{children:"PARALLEL_SERVERS_TARGET"})," to specify the number of parallel execution (PX) worker threads available for the tenant on each node. A parallel query requests worker threads from all related OBServer nodes before being executed. If any OBServer node fails to provide sufficient worker threads, the parallel query is not executed. In this case, the parallel query is put back in the queue. When it is scheduled the next time, it retries to request threads from the nodes until sufficient worker threads are obtained. After the whole query is completed, the requested worker threads are immediately released."]}),"\n",(0,a.jsxs)(r.p,{children:["The process of trying to request worker threads, requeuing due to insufficient thread resources, being scheduled again, and retrying to request worker threads is called ",(0,a.jsx)(r.strong,{children:"parallel query queuing"}),". The allocation of worker threads on all OBServer nodes is managed by a module named ",(0,a.jsx)(r.strong,{children:"PX resource manager"}),"."]}),"\n",(0,a.jsxs)(r.p,{children:["For each parallel query, the PX resource manager splits the execution plan of the query into multiple data flow operations (DFOs), simulates the DFO scheduling process, and calculates the maximum number of worker threads required for the query on each OBServer node based on the PARALLEL hint or table-level PARALLEL attribute. This group of threads is called a ",(0,a.jsx)(r.strong,{children:"resource vector"}),"."]}),"\n",(0,a.jsx)(r.p,{children:"The resource vector is a logical concept used for concurrency control and queuing. After a parallel query requests sufficient worker threads from the PX resource manager based on the resource vector, the parallel query execution starts. During the execution, physical threads are requested and released as different DFOs are scheduled and executed. However, logical threads are not returned to the PX resource manager. The resource vector is returned to the PX resource manager only after the parallel query is completed."}),"\n",(0,a.jsx)(r.p,{children:"When a large number of parallel queries try to request threads from the PX resource manager, threads are allocated based on the First-come, First-serve (FCFS) strategy until no thread is left or the remaining threads are insufficient for any query. All subsequent queries will wait in the queue and retry to request threads when being scheduled again."}),"\n",(0,a.jsx)(r.h2,{id:"32-allocation-of-px-worker-threads",children:"3.2 Allocation of PX Worker Threads"}),"\n",(0,a.jsxs)(r.p,{children:["Each OBServer node of the tenant has a ",(0,a.jsx)(r.strong,{children:"PX thread pool"})," for executing parallel queries. When the threads in the thread pool are insufficient, the thread pool is dynamically scaled out. If threads in the thread pool remain idle for more than 10 minutes, the thread pool is scaled in to 10 threads. If threads in the thread pool remain idle for more than 60 minutes, the thread pool can be scaled in to 0 threads."]}),"\n",(0,a.jsxs)(r.p,{children:["When a parallel query is scheduled, each DFO can obtain required PX threads from the PX thread pool on the corresponding OBServer node. By default, the number of threads allocated to a DFO on an OBServer node cannot exceed the value of ",(0,a.jsx)(r.code,{children:"MIN_CPU"})," of the tenant \xd7 10. If the number of threads requested by a DFO exceeds this value, the thread pool still allocates ",(0,a.jsx)(r.code,{children:"MIN_CPU"})," \xd7 10 threads to the DFO."]}),"\n",(0,a.jsx)(r.h2,{id:"33-two-level-resource-control-model",children:"3.3 Two-level Resource Control Model"}),"\n",(0,a.jsx)(r.p,{children:"Any parallel query experiences two levels of resource control."}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Global control: The parallel query requests a resource vector with sufficient PX threads from the PX resource manager."}),"\n",(0,a.jsx)(r.li,{children:"Local control: The PX thread pool allocates the expected number of physical threads."}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Global control"})," is responsible for resource acquisition in distributed scenarios. ",(0,a.jsx)(r.strong,{children:"Local control"})," is responsible only for resource allocation in the thread pool on a single node. Global control ensures successful execution of a query that passes the check by avoiding the situation where resources cannot be obtained during running. Local control ensures that in extreme circumstances, a single DFO of a query will not request an excessively large number of physical threads, avoiding waste of thread resources. A parallel query that passes the check in the global control phase can be successfully executed. Sufficient physical threads are available for this parallel query regardless of the degree of parallelism (DOP)."]}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.img,{alt:"1705634075",src:t(57775).A+"",width:"1174",height:"858"})}),"\n",(0,a.jsx)(r.h2,{id:"34-view-related-to-px-resource-manager",children:"3.4 View Related to PX Resource Manager"}),"\n",(0,a.jsxs)(r.p,{children:["The PX resource manager can query the ",(0,a.jsx)(r.code,{children:"GV$OB_PX_TARGET_MONITOR"})," view for the thread usage information on each OBServer node of a tenant. For more information about fields in the view, see the ",(0,a.jsx)(r.strong,{children:"GV$OB_PX_TARGET_MONITOR"})," topic of the OceanBase Database documentation."]}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.img,{alt:"1",src:t(54848).A+"",width:"2684",height:"734"})}),"\n",(0,a.jsx)(r.p,{children:"The global resource usage status queried at a specific moment may be inconsistent on different OBServer nodes. However, the global status is synchronized every 500 ms at the background. Generally, the global resource usage status queried on the OBServer nodes is basically consistent without obvious deviations."})]})}function d(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},54848:(e,r,t)=>{t.d(r,{A:()=>a});const a=t.p+"assets/images/1-c8e20cc002cc8f7d51e44847fbe6bfbc.png"},57775:(e,r,t)=>{t.d(r,{A:()=>a});const a=t.p+"assets/images/1705634075415-330e4be9863038c1554d5530c01041be.png"},28453:(e,r,t)=>{t.d(r,{R:()=>l,x:()=>s});var a=t(96540);const n={},o=a.createContext(n);function l(e){const r=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),a.createElement(o.Provider,{value:r},e.children)}}}]);