"use strict";(self.webpackChunkmy_docs_website=self.webpackChunkmy_docs_website||[]).push([[2682],{61333:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>r});var s=n(74848),a=n(28453);const l={title:"Statements for Manual Statistics Collection",weight:3},i=void 0,o={id:"user_manual/operation_and_maintenance/en-US/operations_and_maintenance/optimizer_statistics/command",title:"Statements for Manual Statistics Collection",description:"Note: At present, OceanBase Advanced Tutorial for DBAs applies only to OceanBase Database Community Edition V4.x. Features of Oracle tenants of OceanBase Database Enterprise Edition are not described in this topic. For more information about the differences between the two editions, see Differences between Enterprise Edition and Community Edition.",source:"@site/docs/user_manual/operation_and_maintenance/en-US/operations_and_maintenance/optimizer_statistics/03_command.md",sourceDirName:"user_manual/operation_and_maintenance/en-US/operations_and_maintenance/optimizer_statistics",slug:"/user_manual/operation_and_maintenance/en-US/operations_and_maintenance/optimizer_statistics/command",permalink:"/docs/user_manual/operation_and_maintenance/en-US/operations_and_maintenance/optimizer_statistics/command",draft:!1,unlisted:!1,editUrl:"https://github.com/oceanbase/oceanbase.github.io/tree/main/docs/user_manual/operation_and_maintenance/en-US/operations_and_maintenance/optimizer_statistics/03_command.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Statements for Manual Statistics Collection",weight:3},sidebar:"operation_and_maintenanceEnglishSidebar",previous:{title:"Best Practices for Statistics Collection",permalink:"/docs/user_manual/operation_and_maintenance/en-US/operations_and_maintenance/optimizer_statistics/best_practices"},next:{title:"Parameter Templates",permalink:"/docs/user_manual/operation_and_maintenance/en-US/scenario_best_practices/parameter_templates"}},c={},r=[{value:"Collect Table-level Statistics",id:"collect-table-level-statistics",level:2},{value:"Collect statistics on a non-partitioned table",id:"collect-statistics-on-a-non-partitioned-table",level:3},{value:"Collect statistics on a partitioned table",id:"collect-statistics-on-a-partitioned-table",level:3},{value:"Collect Schema-level Statistics",id:"collect-schema-level-statistics",level:2},{value:"Query Whether Statistics Are Outdated",id:"query-whether-statistics-are-outdated",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["Note: At present, ",(0,s.jsx)(t.em,{children:"OceanBase Advanced Tutorial for DBAs"})," applies only to OceanBase Database Community Edition V4.x. Features of Oracle tenants of OceanBase Database Enterprise Edition are not described in this topic. For more information about the differences between the two editions, see ",(0,s.jsx)(t.a,{href:"https://en.oceanbase.com/docs/common-oceanbase-database-10000000001714481",children:"Differences between Enterprise Edition and Community Edition"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Optimizer statistics are a collection of data that describes the tables and columns in a database, which are the key to selecting the optimal execution plan."}),"\n",(0,s.jsx)(t.p,{children:"In OceanBase Database of a version earlier than V4.x, statistics are mainly collected during daily compactions. However, statistics are not always accurate because of the incremental data involved in daily compactions. In addition, histogram information cannot be collected during daily compactions."}),"\n",(0,s.jsx)(t.p,{children:"Therefore, the statistics feature is upgraded in OceanBase Database V4.x and later, so that statistics are no longer collected during daily compactions. When you use OceanBase Database V4.x, pay special attention to the collection of statistics."}),"\n",(0,s.jsx)(t.p,{children:"This topic recommends some statements for manual statistics collection in actual scenarios."}),"\n",(0,s.jsx)(t.h2,{id:"collect-table-level-statistics",children:"Collect Table-level Statistics"}),"\n",(0,s.jsxs)(t.p,{children:["To explicitly collect statistics on a table, you can use the following methods: ",(0,s.jsx)(t.strong,{children:(0,s.jsx)("font",{color:"red",children:"DBMS_STATS system package and ANALYZE statement"})}),". Pay attention to the table type."]}),"\n",(0,s.jsx)(t.h3,{id:"collect-statistics-on-a-non-partitioned-table",children:"Collect statistics on a non-partitioned table"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)("font",{color:"red",children:"If the product of the number of rows and the number of columns in a table is no greater than 10 million"})}),", we recommend that you run the following statements to collect statistics on the table. In the following example, the ",(0,s.jsx)(t.code,{children:"t1"})," table owned by the ",(0,s.jsx)(t.code,{children:"test"})," user contains 10 columns and one million rows:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"create table test.t1(\n    c1 int, c2 int, c3 int, c4 int, c5 int, \n    c6 int, c7 int, c8 int, c9 int, c10 int);\n\ninsert /*+append*/ into t1 \n    select level,level,level,level,level,\n           level,level,level,level,level\n    from dual\n    connect by level <= 1000000;\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"-- re1. Histograms are not collected.\n\ncall dbms_stats.gather_table_stats(\n    'test',\n    't1',\n    method_opt=>'for all columns size 1');\n\n\n-- re2. Histograms are collected by using the default strategy.\n\ncall dbms_stats.gather_table_stats('test', 't1');\n\n-- The collection takes about 2 seconds.\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)("font",{color:"red",children:"If the product of the number of rows and the number of columns in a table exceeds 10 million"})}),", we recommend that you specify an appropriate degree of parallelism (DOP) based on your business requirements and system resources to accelerate the statistics collection. In the following example, the DOP is set to 8 when the data amount in the ",(0,s.jsx)(t.code,{children:"t1"})," table is increased to 10 million rows:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"create table test.t1(\n    c1 int, c2 int, c3 int, c4 int, c5 int,\n    c6 int, c7 int, c8 int, c9 int, c10 int);\n\ninsert /*+append*/ into t1 \n    select level,level,level,level,level,\n           level,level,level,level,level\n    from dual\n    connect by level <= 10000000;\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"-- re1. Histograms are not collected.\n\ncall dbms_stats.gather_table_stats(\n    'test',\n    't1',\n    degree=>8,\n    method_opt=>'for all columns size 1');\n\n-- re2. Histograms are collected by using the default strategy.\n\ncall dbms_stats.gather_table_stats(\n    'test',\n    't1',\n    degree=>8);\n\n-- The collection takes about 4 seconds.\n"})}),"\n",(0,s.jsx)(t.h3,{id:"collect-statistics-on-a-partitioned-table",children:"Collect statistics on a partitioned table"}),"\n",(0,s.jsx)(t.p,{children:"Different from statistics collection strategies for non-partitioned tables, the strategies for partitioned tables must cover the collection of partition statistics."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)("font",{color:"red",children:"If system resources are sufficient, we recommend that you double the DOP for statistics collection on partitioned tables."})})," For example, the ",(0,s.jsx)(t.code,{children:"t_part"})," table of the ",(0,s.jsx)(t.code,{children:"test"})," user contains 128 partitions, 10 columns, and one million rows of data. In this case, you can set the DOP to 2 to collect the basic statistics and partition statistics:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"create table t_part(\n    c1 int, c2 int, c3 int, c4 int, c5 int,\n    c6 int, c7 int, c8 int, c9 int, c10 int\n)partition by hash(c1) partitions 128;\n\ninsert /*+append*/ into t_part \n    select level,level,level,level,level,\n           level,level,level,level,level\n    from dual\n    connect by level <= 1000000;\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"-- Specify an appropriate DOP:\n\n-- re1. Histograms are not collected.\n\ncall dbms_stats.gather_table_stats(\n    'test',\n    't_part',\n    degree=>2,\n    method_opt=>'for all columns size 1');\n\n-- re2. Histograms are collected by using the default strategy.\n\ncall dbms_stats.gather_table_stats(\n    'test',\n    't_part',\n    degree=>2);\n\n-- The collection takes about 4 seconds.\n"})}),"\n",(0,s.jsxs)(t.p,{children:["For partitioned tables, ",(0,s.jsx)(t.strong,{children:(0,s.jsx)("font",{color:"red",children:"you can also deduce global statistics from partition-level statistics to accelerate statistics collection"})}),". That is, you can modify the collection granularity to ",(0,s.jsx)(t.code,{children:"APPROX_GLOBAL AND PARTITION"})," instead of increasing the DOP for statistics collection on the ",(0,s.jsx)(t.code,{children:"t_part"})," table."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"-- re1. Histograms are not collected.\n\ncall dbms_stats.gather_table_stats(\n    'test', \n    't_part', \n    granularity=>'APPROX_GLOBAL AND PARTITION', \n    method_opt=>'for all columns size 1');\n\n-- re2. Histograms are collected by using the default strategy.\n\ncall dbms_stats.gather_table_stats(\n    'test',\n    't_part',\n    granularity=>'APPROX_GLOBAL AND PARTITION');\n\n-- The collection takes about 4 seconds.\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:(0,s.jsx)("font",{color:"red",children:"In summary, you can specify an appropriate DOP or deduce global statistics from partition-level statistics to accelerate statistics collection on partitioned tables."})})}),"\n",(0,s.jsx)(t.h2,{id:"collect-schema-level-statistics",children:"Collect Schema-level Statistics"}),"\n",(0,s.jsxs)(t.p,{children:["In addition to manual statistics collection on a single table, you can use the ",(0,s.jsx)(t.code,{children:"DBMS_STATS"})," system package to collect statistics on all tables of a user."]}),"\n",(0,s.jsx)(t.p,{children:"This process is time-consuming. Therefore, we recommend that you use this feature during off-peak hours."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["If ",(0,s.jsx)(t.strong,{children:(0,s.jsx)("font",{color:"red",children:"each table of the user contains no more than one million rows"})}),", you can run the statements in the following example to collect statistics:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"\n-- re1. Histograms are not collected.\n\ncall dbms_stats.gather_schema_stats('TEST', method_opt=>'for all columns size 1');\n\n\n-- re2. Histograms are collected by using the default strategy.\n\ncall dbms_stats.gather_schema_stats('TEST');\n\n"})}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["If ",(0,s.jsx)(t.strong,{children:(0,s.jsx)("font",{color:"red",children:"the user has large tables and each large table contains tens of millions of rows"})}),", you can increase the DOP and collect statistics during off-peak hours."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"\n-- re1. Histograms are not collected.\n\ncall dbms_stats.gather_schema_stats(\n    'TEST',\n    degree=>'16',\n    method_opt=>'for all columns size 1');\n\n-- re2. Histograms are collected by using the default strategy.\n\ncall dbms_stats.gather_schema_stats('TEST', degree=>'16');\n"})}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["If ",(0,s.jsx)(t.strong,{children:(0,s.jsx)("font",{color:"red",children:"the user has ultra-large tables and each ultra-large table contains more than 100 million rows, you can collect statistics on the ultra-large tables separately at a high DOP"})}),". Then, you can lock the statistics on the ultra-large tables and execute the preceding statements to collect statistics on all tables of the user. After the statistics are collected, you can unlock the statistics on the ultra-large tables and then collect the subsequent statistics in incremental mode. Here is an example:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"call dbms_stats.gather_table_stats(\n    'test',\n    'big_table',\n    degree=>128,\n    method_opt=>'for all columns size 1');\n\ncall dbms_stats.lock_table_stats('test','big_table');\n\ncall dbms_stats.gather_schema_stats(\n    'TEST',\n    degree=>'16',\n    method_opt=>'for all columns size 1');\n\ncall dbms_stats.unlock_table_stats('test','big_table');\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"query-whether-statistics-are-outdated",children:"Query Whether Statistics Are Outdated"}),"\n",(0,s.jsx)(t.p,{children:"The following SQL statements apply only to OceanBase Database V4.2 and later:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sql",children:"select distinct DATABASE_NAME, TABLE_NAME\n    from oceanbase.DBA_OB_TABLE_STAT_STALE_INFO\n    where DATABASE_NAME not in('oceanbase','mysql', '__recyclebin')\n        and (IS_STALE = 'YES' or LAST_ANALYZED_TIME is null);\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"select distinct OWNER, TABLE_NAME\n    from sys.DBA_OB_TABLE_STAT_STALE_INFO\n    where OWNER != 'oceanbase'\n        and OWNER != '__recyclebin' and (IS_STALE = 'YES' or LAST_ANALYZED_TIME is null);\n"})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var s=n(96540);const a={},l=s.createContext(a);function i(e){const t=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(l.Provider,{value:t},e.children)}}}]);