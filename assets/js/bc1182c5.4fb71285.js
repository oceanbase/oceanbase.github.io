"use strict";(self.webpackChunkmy_docs_website=self.webpackChunkmy_docs_website||[]).push([[4602],{23678:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var t=n(74848),o=n(28453);const i={title:"Background Knowledge of the Storage Engine",weight:2},s=void 0,r={id:"user_manual/operation_and_maintenance/en-US/scenario_best_practices/chapter_02_archive_database/background_knowledge",title:"Background Knowledge of the Storage Engine",description:"In the process of collecting suggestions for this advanced tutorial, many users hope to learn more about the background knowledge and the implementation principles of key technologies. Therefore, this topic is added to brief the architecture of the OceanBase Database storage engine, the encoding and compression technologies adopted by the database system, as well as several ways to reduce the impact of encoding on the query performance.",source:"@site/docs/user_manual/operation_and_maintenance/en-US/scenario_best_practices/chapter_02_archive_database/02_background_knowledge.md",sourceDirName:"user_manual/operation_and_maintenance/en-US/scenario_best_practices/chapter_02_archive_database",slug:"/user_manual/operation_and_maintenance/en-US/scenario_best_practices/chapter_02_archive_database/background_knowledge",permalink:"/docs/user_manual/operation_and_maintenance/en-US/scenario_best_practices/chapter_02_archive_database/background_knowledge",draft:!1,unlisted:!1,editUrl:"https://github.com/oceanbase/oceanbase.github.io/tree/main/docs/user_manual/operation_and_maintenance/en-US/scenario_best_practices/chapter_02_archive_database/02_background_knowledge.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Background Knowledge of the Storage Engine",weight:2},sidebar:"operation_and_maintenanceEnglishSidebar",previous:{title:"Introduction",permalink:"/docs/user_manual/operation_and_maintenance/en-US/scenario_best_practices/chapter_02_archive_database/introduction"},next:{title:"Best Practices for Archiving Historical Data",permalink:"/docs/user_manual/operation_and_maintenance/en-US/scenario_best_practices/chapter_02_archive_database/data_archive_best_practices"}},c={},d=[{value:"Architecture of the Storage Engine",id:"architecture-of-the-storage-engine",level:2},{value:"Data Compression and Encoding Technologies",id:"data-compression-and-encoding-technologies",level:2},{value:"Encoding technology for compression",id:"encoding-technology-for-compression",level:3},{value:"Reduced bit width for storage: bit-packing and hex encoding",id:"reduced-bit-width-for-storage-bit-packing-and-hex-encoding",level:4},{value:"Data deduplication for a single column: dictionary encoding and RLE",id:"data-deduplication-for-a-single-column-dictionary-encoding-and-rle",level:4},{value:"Value range-based data compression: delta encoding",id:"value-range-based-data-compression-delta-encoding",level:4},{value:"Reduced redundancy across columns: span-column encoding",id:"reduced-redundancy-across-columns-span-column-encoding",level:4},{value:"Adaptive compression",id:"adaptive-compression",level:3},{value:"Reduce the impact of data encoding on the query performance",id:"reduce-the-impact-of-data-encoding-on-the-query-performance",level:3},{value:"Row-level random access",id:"row-level-random-access",level:4},{value:"Computation pushdown",id:"computation-pushdown",level:4},{value:"Basic test of encoding and compression",id:"basic-test-of-encoding-and-compression",level:3}];function h(e){const a={blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(a.blockquote,{children:["\n",(0,t.jsx)(a.p,{children:"In the process of collecting suggestions for this advanced tutorial, many users hope to learn more about the background knowledge and the implementation principles of key technologies. Therefore, this topic is added to brief the architecture of the OceanBase Database storage engine, the encoding and compression technologies adopted by the database system, as well as several ways to reduce the impact of encoding on the query performance."}),"\n"]}),"\n",(0,t.jsxs)(a.blockquote,{children:["\n",(0,t.jsx)(a.p,{children:"The content marked red in this topic is easily ignored when you use OceanBase Database in a test or production environment, which may lead to serious impact. We recommend that you pay more attention to such content."}),"\n"]}),"\n",(0,t.jsx)(a.h2,{id:"architecture-of-the-storage-engine",children:"Architecture of the Storage Engine"}),"\n",(0,t.jsxs)(a.p,{children:["Generally, a history database is ",(0,t.jsx)(a.strong,{children:"write-intensive"})," (with more writes than reads). Based on the log-structured merge-tree (LSM-tree), the storage engine of OceanBase Database is endowed with high write performance. In a history database, direct load is leveraged to efficiently synchronize data in batches periodically, with data update and real-time data synchronization supported."]}),"\n",(0,t.jsx)(a.p,{children:"The storage engine of OceanBase Database stores baseline data in baseline SSTables and incremental data in MemTables and incremental SSTables. The baseline data is read-only and cannot be modified. Incremental data supports both read and write operations."}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.img,{alt:"image",src:n(23316).A+"",width:"1600",height:"1000"})}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsxs)(a.strong,{children:["In OceanBase Database, DML operations such as ",(0,t.jsx)(a.code,{children:"INSERT"}),", ",(0,t.jsx)(a.code,{children:"UPDATE"}),", and ",(0,t.jsx)(a.code,{children:"DELETE"})," are first written to MemTables in memory. This means that the data write performance is equivalent to that of an in-memory database, which agrees with the write-intensive scenario of our history database."]})}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.strong,{children:"When the size of a MemTable reaches the specified threshold, data in the MemTable is dumped to an incremental SSTable on the disk, as shown in the preceding figure. The dumping process is performed sequentially in batches, delivering much higher performance compared with the discrete random writing of a B+ tree-based storage engine."})}),"\n",(0,t.jsx)(a.p,{children:"When the size of an incremental SSTable reaches the specified threshold, incremental data in the SSTable is merged with the existing baseline data to produce new baseline data. This process is referred to as a major compaction. Then, the new baseline data remains unchanged until the next major compaction. OceanBase Database automatically performs a major compaction during off-peak hours early in the morning on a daily basis."}),"\n",(0,t.jsx)(a.p,{children:"A downside of the LSM-tree architecture is that it causes read amplification, as shown by the right-side arrows in the preceding figure. Upon a query request, OceanBase Database queries SSTables and MemTables separately, merges the query results, and then returns the merged result to the SQL layer. To mitigate the impact of read amplification, OceanBase Database implements multiple layers of caches in memory, such as the block cache and row cache, to avoid frequent random reads of baseline data."}),"\n",(0,t.jsx)(a.p,{children:"The history database contains a small amount of incremental data and most data is stored in baseline SSTables. Therefore, for regular batch processing reports of the history database and extensive data scan in ad-hoc analytical queries, computations can be pushed down to the baseline SSTables to bypass the general issue of read amplification in the LSM-tree architecture. OceanBase Database supports pushing down operators on compressed data and uses a compression format that supports vectorized decoding. This way, it can easily process a large amount of data queries and computations."}),"\n",(0,t.jsx)(a.p,{children:"The SSTable storage format and data encoding and compression technologies enable OceanBase Database to store massive amounts of historical data. The high compression ratio and the higher query performance on equivalent hardware can significantly reduce the storage and computation costs."}),"\n",(0,t.jsx)(a.p,{children:"In addition, enterprises can choose to deploy the cluster of the history database on more cost-effective hardware, where data encoding and compression configurations hardly need to be considered during database O&M. In terms of application development, the same interface can be used to access the online database and history database, which simplifies the application code and architecture."}),"\n",(0,t.jsx)(a.p,{children:"Attracted by these characteristics, more and more enterprises begin to use an OceanBase database as their history database. In the future, OceanBase Database will continue to seek breakthroughs in storage architecture, cost reduction, and efficiency improvement."}),"\n",(0,t.jsx)(a.h2,{id:"data-compression-and-encoding-technologies",children:"Data Compression and Encoding Technologies"}),"\n",(0,t.jsx)(a.p,{children:"OceanBase Database supports both compression and encoding. Compression does not consider data characteristics, while encoding compresses data by column based on data characteristics. The two methods are orthogonal, meaning that we can first encode a data block and then compress it to achieve a higher compression ratio."}),"\n",(0,t.jsx)(a.p,{children:"At the stage of compression, OceanBase Database uses compression algorithms to compress a microblock without considering the data format, and eliminate data redundancy if detected. OceanBase Database supports zlib, snappy, zstd, and lz4 algorithms for compression. You can use DDL statements to configure and change the compression algorithms for tables based on table application scenarios."}),"\n",(0,t.jsxs)(a.blockquote,{children:["\n",(0,t.jsxs)(a.p,{children:["Note: The concept of microblock is similar to the concepts of page and block in conventional databases. In the LSM-tree architecture, microblocks in OceanBase Database are compressed and become longer after compression. When you create a table, you can set the ",(0,t.jsx)(a.code,{children:"block_size"})," parameter to specify the size of microblocks before compression. (Now you know the meaning of the ",(0,t.jsx)(a.code,{children:"block_size"})," parameter in the output of the ",(0,t.jsx)(a.code,{children:"SHOW CREATE TABLE"})," statement.)"]}),"\n"]}),"\n",(0,t.jsxs)(a.p,{children:[(0,t.jsxs)(a.strong,{children:["You can set ",(0,t.jsx)(a.code,{children:"block_size"}),", which defaults to ",(0,t.jsx)(a.code,{children:"16KB"}),", to a larger value to achieve a higher compression ratio. However, this may compromise the read performance because microblock is the smallest unit of read I/O operations. If you want to read a specific row of data in a microblock, only this row of data is decoded. This prevents specific decompression algorithms from decompressing the entire data block when you want to read only a part of data in the data block. If you set ",(0,t.jsx)(a.code,{children:"block_size"})," to a large value, microblocks with data updates cannot be reused during a major compaction but must be rewritten, which slows down the major compaction."]})," ",(0,t.jsx)(a.strong,{children:(0,t.jsxs)("font",{color:"red",children:["Adjusting the value of the ",(0,t.jsx)(a.code,{children:"block_size"})," parameter has its pros and cons. You can modify the parameter value as needed after you understand the meaning and impact. We recommend that you use the default value."]})})]}),"\n",(0,t.jsx)(a.p,{children:"Before data is read from a compressed microblock, the whole microblock is decompressed for scanning, which causes CPU overhead. To minimize the impact of decompression on the query performance, OceanBase Database assigns the decompression task to asynchronous I/O threads and then stores the decompressed microblocks in the block cache as needed. This, combined with query prefetching, provides a pipeline of microblocks for query processing threads and eliminates the additional overhead due to decompression."}),"\n",(0,t.jsx)(a.h3,{id:"encoding-technology-for-compression",children:"Encoding technology for compression"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsx)(a.p,{children:"Data is stored in columns by city, gender, product category, and other classification attributes. In this case, data in each column has a small cardinality. We can create dictionaries directly on these columns to achieve a higher compression ratio."}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsx)(a.p,{children:"If data is inserted into the database in chronological order, time-related columns and auto-increment columns of the inserted rows have small value ranges, and their values increase monotonically. We can make use of these characteristics and apply encoding algorithms such as bit-packing and delta encoding quite easily."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"To achieve a higher compression ratio and help users slash storage costs, OceanBase Database has developed a variety of encoding algorithms that have worked well. In addition to single-column encoding algorithms, such as bit-packing, hex encoding, dictionary encoding, run-length encoding (RLE), constant encoding, delta encoding for numeric data, and delta encoding for fixed-length strings, OceanBase Database also provides innovative span-column equal encoding and column prefix encoding to compress different types of redundant data in one or several columns, respectively."}),"\n",(0,t.jsx)(a.h4,{id:"reduced-bit-width-for-storage-bit-packing-and-hex-encoding",children:"Reduced bit width for storage: bit-packing and hex encoding"}),"\n",(0,t.jsx)(a.p,{children:"Bit-packing and hex encoding are similar in that they represent the original data by encoding it with fewer bits if the cardinality of data is small. Moreover, these two encoding algorithms are not exclusive, which means that you can perform bit-packing or hex encoding on numeric data or strings generated by other encoding algorithms to further reduce data redundancy."}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.img,{alt:"image",src:n(42223).A+"",width:"539",height:"151"})}),"\n",(0,t.jsx)(a.p,{children:"(Bit-packing)"}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.img,{alt:"image",src:n(19558).A+"",width:"520",height:"201"})}),"\n",(0,t.jsx)(a.p,{children:"(Hex encoding)"}),"\n",(0,t.jsx)(a.h4,{id:"data-deduplication-for-a-single-column-dictionary-encoding-and-rle",children:"Data deduplication for a single column: dictionary encoding and RLE"}),"\n",(0,t.jsx)(a.p,{children:"We can create a dictionary for a data block to compress data with a low cardinality. If the distribution of data with a low cardinality in a microblock conforms to corresponding characteristics, you can use an encoding method such as RLE or constant encoding to further compress the data."}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.img,{alt:"image",src:n(12633).A+"",width:"651",height:"311"})}),"\n",(0,t.jsx)(a.p,{children:"(Dictionary encoding and RLE)"}),"\n",(0,t.jsxs)(a.blockquote,{children:["\n",(0,t.jsx)(a.p,{children:"Note: In the RLE on the rightmost of the preceding figure, the values 0, 4, and 6 in the first column are the initial subscripts of 0, 1, and 2 in the right-side dictionary encoding. RLE and dictionary encoding apply to scenarios with a large amount of continuous duplicate data."}),"\n"]}),"\n",(0,t.jsx)(a.h4,{id:"value-range-based-data-compression-delta-encoding",children:"Value range-based data compression: delta encoding"}),"\n",(0,t.jsx)(a.p,{children:"OceanBase Database supports delta encoding for numeric data and delta encoding for fixed-length strings. Delta encoding for numeric data is suitable for compressing numeric data in a small value range. To compress date, timestamp, or other numeric data of small adjacent differences, we can keep the minimum value, and store the difference between the original data and the minimum value in each row. Delta encoding for fixed-length strings is a better choice for compressing artificially generated nominal numbers, such as order IDs and ID card numbers, as well as strings of a certain pattern, such as URLs. We can specify a pattern string for a microblock of such data and store the difference between the original string and the pattern string in each row to achieve better compression results."}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.img,{alt:"image",src:n(15728).A+"",width:"376",height:"281"})}),"\n",(0,t.jsx)(a.p,{children:"(Delta encoding for numeric data)"}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.img,{alt:"image",src:n(91608).A+"",width:"421",height:"201"})}),"\n",(0,t.jsx)(a.p,{children:"(Delta encoding for fixed-length strings)"}),"\n",(0,t.jsx)(a.h4,{id:"reduced-redundancy-across-columns-span-column-encoding",children:"Reduced redundancy across columns: span-column encoding"}),"\n",(0,t.jsx)(a.p,{children:"OceanBase Database provides span-column encoding to improve the compression ratio by making use of the data similarity between different columns. Technically, a columnar storage database encodes data only within columns. In an actual business database, however, it is common that data in different columns are associated. In this case, you can use one column to represent part of the information of another column."}),"\n",(0,t.jsx)(a.p,{children:"Span-column encoding outperforms other encoding algorithms in the compression of composite columns and system-generated data, and can also reduce the data redundancy due to inappropriate table design paradigms."}),"\n",(0,t.jsxs)(a.blockquote,{children:["\n",(0,t.jsx)(a.p,{children:"Note: Span-column encoding is used only for columns with certain associations, for example, most data of two columns is equivalent or the data of one column is the prefix or substring of another column."}),"\n"]}),"\n",(0,t.jsx)(a.h3,{id:"adaptive-compression",children:"Adaptive compression"}),"\n",(0,t.jsx)(a.p,{children:"Adaptive compression allows the database system to select an optimal encoding algorithm."}),"\n",(0,t.jsx)(a.p,{children:"The compression performance of data encoding algorithms is related not only to the table schema but also to data characteristics such as the distribution of data and the value range of data within a microblock. This means it is hard to achieve the best compression performance by specifying a columnar encoding algorithm when you design the table data model."}),"\n",(0,t.jsx)(a.p,{children:"To make your work easier and improve the compression performance, OceanBase Database can analyze characteristics such as the data type, value range, and number of distinct values (NDV) of a column during major compaction. It can also select an appropriate encoding algorithm based on the encoding algorithm and compression ratio of the corresponding column in the previous microblock in the compaction task. OceanBase Database supports encoding the same column in different microblocks with different algorithms while ensuring that the overhead in selecting an encoding algorithm is within an acceptable range."}),"\n",(0,t.jsx)(a.h3,{id:"reduce-the-impact-of-data-encoding-on-the-query-performance",children:"Reduce the impact of data encoding on the query performance"}),"\n",(0,t.jsx)(a.p,{children:"To better balance compression performance and query performance, we have considered the impact on the query performance when designing data encoding methods."}),"\n",(0,t.jsx)(a.h4,{id:"row-level-random-access",children:"Row-level random access"}),"\n",(0,t.jsx)(a.p,{children:"In compression scenarios, the whole data block will be decompressed even if you want to access just a part of data in it. When you access a row in some analytical systems intended for scan queries rather than point queries, adjacent or all rows in the database are decoded."}),"\n",(0,t.jsx)(a.p,{children:"To better support transactional workloads, OceanBase Database needs to support more efficient point queries. Therefore, our encoding methods ensure row-level random access to encoded data. To be specific, the database accesses and decodes only the metadata of the target row in a point query, which reduces the computational amplification during random point queries. In addition, OceanBase Database stores all metadata required for decoding data in a microblock just within the microblock, so that the microblock is self-describing with better memory locality during decoding."}),"\n",(0,t.jsxs)(a.blockquote,{children:["\n",(0,t.jsx)(a.p,{children:"Note: In other words, when you perform a point query, OceanBase Database can decode a single row rather than the whole microblock."}),"\n"]}),"\n",(0,t.jsx)(a.h4,{id:"computation-pushdown",children:"Computation pushdown"}),"\n",(0,t.jsx)(a.p,{children:"Furthermore, since we store ordered dictionaries, null bitmaps, constants, and other metadata in a microblock to describe the distribution of the encoded data, we can use the metadata to optimize the execution of some filter and aggregate operators during a data scan, and to perform computations directly on the encoded data."}),"\n",(0,t.jsx)(a.p,{children:"OceanBase Database significantly strengthened its analytical processing capabilities. In the latest versions, aggregation and filtering are pushed down to the storage layer and the vectorized engine is used for vectorized batch decoding based on the columnar storage characteristics of encoded data."}),"\n",(0,t.jsx)(a.p,{children:"When processing a query, OceanBase Database performs computations directly on the encoded data by making full use of the encoding metadata and the locality of encoded data stored in a columnar storage architecture. This brings a significant increase in the execution efficiency of the pushed-down operators and the data decoding efficiency of the vectorized engine. Data encoding-based operator push-down and vectorized decoding are also important features that have empowered OceanBase Database to efficiently handle analytical workloads and demonstrate an extraordinary performance in TPC-H benchmark tests."}),"\n",(0,t.jsxs)(a.blockquote,{children:["\n",(0,t.jsx)(a.p,{children:"Note: In other words, for common filter conditions and simple aggregate computations, the storage layer does not need to transfer data to the SQL layer for computation. OceanBase Database can directly complete the computations in the storage layer, saving the overhead for the storage layer to return rows to the SQL layer. OceanBase Database also supports directly performing computations on encoded data, saving the overhead in decoding."}),"\n"]}),"\n",(0,t.jsx)(a.h3,{id:"basic-test-of-encoding-and-compression",children:"Basic test of encoding and compression"}),"\n",(0,t.jsx)(a.p,{children:"We performed a simple test to see the influence of different compression methods on the compression performance of OceanBase Database."}),"\n",(0,t.jsx)(a.p,{children:"We used OceanBase Database V4.0 to test the compression ratio with a TPC-H 10 GB data model in transaction scenarios and with an IJCAI-16 Brick-and-Mortar Store Recommendation Dataset in user behavior log scenarios."}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsx)(a.p,{children:"The TPC-H model simulated real-life order and transaction processing. We tested the compression ratios of two large tables in the TPC-H model: ORDERS table, which stores order information, and LINEITEM table, which stores product information. Under the default configuration where both the zstd and encoding algorithms were used, the compression ratio of the two tables reached about 4.6 in OceanBase Database, much higher than the compression ratio achieved when only the encoding or zstd algorithm was used."}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsx)(a.p,{children:"The IJCAI-16 taobao user log dataset stored desensitized real behavior logs of Taobao users. The compression ratio reached 9.9 when the zstd and encoding algorithms were combined, 8.3 for the encoding algorithm alone, and 6.0 for the zstd algorithm alone."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.img,{alt:"image",src:n(48098).A+"",width:"1000",height:"578"})})]})}function l(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},23316:(e,a,n)=>{n.d(a,{A:()=>t});const t=n.p+"assets/images/001-1c5cdd123fc6a292a83a63731c3ba2a5.png"},42223:(e,a,n)=>{n.d(a,{A:()=>t});const t=n.p+"assets/images/002-0d8d9b8fd0cb06534a556cf3a7f24658.png"},19558:(e,a,n)=>{n.d(a,{A:()=>t});const t=n.p+"assets/images/003-fd172611c0f8e6776badfc343299977b.png"},12633:(e,a,n)=>{n.d(a,{A:()=>t});const t=n.p+"assets/images/004-292dd82215cc27ab91e92155ab890bf3.png"},15728:(e,a,n)=>{n.d(a,{A:()=>t});const t=n.p+"assets/images/005-2080827beaac9e6056ba591cfd080bdf.png"},91608:(e,a,n)=>{n.d(a,{A:()=>t});const t=n.p+"assets/images/006-b44b5f8fd190e003660dc07dbafe67d4.png"},48098:(e,a,n)=>{n.d(a,{A:()=>t});const t=n.p+"assets/images/007-35e47ab008184998ab35b351c6587c68.png"},28453:(e,a,n)=>{n.d(a,{R:()=>s,x:()=>r});var t=n(96540);const o={},i=t.createContext(o);function s(e){const a=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(i.Provider,{value:a},e.children)}}}]);